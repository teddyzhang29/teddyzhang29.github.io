---
layout: post
title: "从PSD生成UnityUI-PSDUI"
tags: [游戏开发]
header-img: "img/header/psdui.jpg"
---

一款游戏中通常有数十个UI界面, 制作这些UI需要耗费大量人力. 一般情况下, 一个UI由美术在设计软件中设计完毕后, 向制作人员给出最终效果图和各图片的切图. 制作人员根据这些资源在引擎中手动创建出这个UI资源. 
传统的开发方式存在一些问题。

**耗时**  
通常有两种方式来拼界面:一种是由美术人员在效果图标识切图的尺寸,四边距,文字的字号,字体颜色等,UI制作人员只负责输入对应数值.  
另一种则是将效果图调至半透明叠在下方,通过肉眼调整每一张切图和文字的效果.  
不管使用哪种方式,为了达到近乎完美的效果以匹配效果图中的每一个像素,这将耗费巨大的精力和时间.

**难以迭代**  
开发过程中UI的迭代可能会非常频繁. 在传统开发方式下, 每次迭代都需要人工识别出改动的位置, 有时甚至会出现美术人员做一些很小的变动而不通知UI制作人员的情况. 例如美术可能会觉得某个文字加个描边效果会好一点, 然后自己就默默改了. 这使得UI制作这项工作变得异常困难, 因为你不仅活要好, 眼神也要好.

**难以合并**  
当UI的修改被分散到每个开发人员手中时，产生冲突就在所难免。 虽然Unity也是使用文本的方式保存预设文件， 但是相对于机器而言， 人类阅读yaml的能力就显得差很多， 尤其在一个巨无霸预设面前， 恐怕没有勇士敢于手动合并这些冲突。 那么此时最保险的做法就是使用别人的改动，自己再重做一次。

## 使用PSDUI

PSDUI用于帮助开发者解决以上问题。 因此，基本上将上述问题反过来即是其优点。

**省时**  
除了首次出图时需要对PSD做一些配置外，后续都可以一键完成美术资源导出。开发人员不再需要手动搭建UI而是改为自动生成， 通常一个UI几秒内即可生成完毕。

**精确**  
相对传统的手动搭建UI， 自动生成的UI会严格匹配到PSD中的每一个像素， 保证最终产品与效果图一致。 因此验收人员也不再需要严格对照效果图验证一致性，只需验证功UI上功能是否齐全即可。  
传统模式下因为人为无法精确匹配效果图，UI最终质量往往有所下降。PSDUI的精确性同时也确保了游戏最终品质不会在UI上打折扣。

**易于合并**  
使用工具生成UI的一个原则是：不再手动对最终产品做任何**不可复原**的修改。 这里**不可复原**指的是再生成UI后会丢失的改动，即尽量不手动修改预设，如果要手动修改，需要确保再次生成可以将本次改动复原。  
基于以上原则， 当预设冲突后只需要使用其中一方的版本，然后再生成一次预设即可。

虽然工具生成有很多显著的优势，但是很遗憾的是它也不可避免的有一些缺陷，其中我认为最大的挑战是美术人员不再纯粹的关注美术设计，也需要了解一些最终产品的逻辑和该工具的规则。美术人员需要了解常用控件的表示方式（例如Button，Toggle, InputField等）；需要了解最终产品的层次结构，因为层次结构基本由美术人员控制而又会影响到开发人员对程序的实现，因此通常使用工具生成，在美术人员准备出图时需要与客户端程序一起确定层次结构。

### 原理

PSDUI提供一个配套的JS脚本导出PSD文件,脚本通过解析图层结构和名称生成**图片切图+配置文件**. 配置文件中记录了各控件的一些信息. 有些信息会从PS中读取, 例如:图片尺寸,位置,字体颜色等. 

```
配置内容
```

有些信息需要设计人员提供,例如:Button的过渡是改变颜色还是改变图片, 这些信息需要写在图层的名称里.  
解析名称时采用`图层名称[@类型][命令1][命令2]...`的规则。  
`图层名称`会被应用于对应UI结点的名称.  
`[@类型]`用来表示复杂的控件。因为PS里只有图层和文件夹, 只能用于表示图片和文字，所以当需要表示更复杂的类型时需要通过`[@类型]`来表示.
例如:一个Button需要在文件夹名称上使用`[@Button]`表示,然后在文件夹内放入图片和文字, 最终生成的UI里这张图片会被Button引用作为默认状态的图片, 然后在Button的子节点创建一个Text显示文字.
```
|--Button
|   └─Text
```
`[命令]`用于给控件附加额外功能。例如:`[outline]`用于给文字加上描边。`[outline:thinkness:color]`可以设置描边的宽度和颜色。

使用PSDUI时会有一些常用需求， 这里列出一些简述。

###  脚本恢复

---

* 开发背景
* 原始模式弊端
* 原理

1. 控件描述(规则表)
* 技术难点
2. 脚本恢复

* 新功能
1. 自定义控件
2. 自定义图集
3. 静态字体

* 结语